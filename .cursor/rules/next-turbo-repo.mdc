---
alwaysApply: true
---
# Reglas de Desarrollo - Ganga Menu Project

## ğŸ“‹ Principios Fundamentales

### 1. Principios SOLID
- **Single Responsibility**: Cada funciÃ³n, clase y componente debe tener una sola responsabilidad
- **Open/Closed**: Abierto para extensiÃ³n, cerrado para modificaciÃ³n
- **Liskov Substitution**: Los objetos deben ser reemplazables por instancias de sus subtipos
- **Interface Segregation**: Interfaces especÃ­ficas en lugar de interfaces generales
- **Dependency Inversion**: Depender de abstracciones, no de concreciones

### 2. Mejores PrÃ¡cticas Next.js
- **NO usar `useEffect` innecesariamente**: Aprovecha SSR/CSR apropiadamente
- Usar Server Components por defecto, Client Components solo cuando sea necesario
- Implementar loading states y error boundaries
- Usar Next.js Image optimization
- Implementar SEO correctamente con metadata API
- Usar App Router en lugar de Pages Router

### 3. GestiÃ³n de Datos
- **NO mockear datos a menos que se solicite explÃ­citamente**
- Usar datos reales de @packages/database siempre que sea posible
- Si necesitas datos de prueba, usar @packages/testing/fixtures
- Validar datos con schemas (Zod o similar)

### 4. InternacionalizaciÃ³n y Textos
- **NUNCA hardcodear textos directamente en los componentes**
- **SIEMPRE usar @repo/internationalization para todos los textos**
- Agregar nuevas traducciones al dictionary cuando se necesiten
- Usar el patrÃ³n `dictionary.web.section.key` para organizar textos
- Proporcionar fallbacks descriptivos pero siempre usar el dictionary

### 5. Modularidad y ReutilizaciÃ³n
- **SIEMPRE revisar si existe un package que solucione el problema**
- Crear componentes reutilizables en @packages/design-system
- Separar lÃ³gica de negocio en @packages/data-services
- Usar custom hooks para lÃ³gica compartida

## ğŸ—ï¸ Estructura del Proyecto

### Apps Structure
```
apps/
â”œâ”€â”€ app/                    # AplicaciÃ³n principal Next.js
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ [locale]/
â”‚   â”‚   â”‚   â”œâ”€â”€ (authenticated)/
â”‚   â”‚   â”‚   â”œâ”€â”€ (public)/
â”‚   â”‚   â”‚   â””â”€â”€ layout.tsx
â”‚   â”‚   â”œâ”€â”€ globals.css
â”‚   â”‚   â””â”€â”€ layout.tsx
â”‚   â”œâ”€â”€ components/         # Componentes especÃ­ficos de la app
â”‚   â”œâ”€â”€ lib/               # Utilidades especÃ­ficas de la app
â”‚   â””â”€â”€ types/             # Tipos especÃ­ficos de la app
â”œâ”€â”€ api/                   # API backend
â”œâ”€â”€ web/              # Template base
â”œâ”€â”€ docs/                  # DocumentaciÃ³n
â”œâ”€â”€ email/                 # Servicio de emails
â”œâ”€â”€ storybook/             # DocumentaciÃ³n de componentes
â””â”€â”€ studio/                # CMS Studio
```

### Packages Structure
```
packages/
â”œâ”€â”€ design-system/         # Componentes UI reutilizables
â”‚   â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ icons/
â”‚   â””â”€â”€ theme/
â”œâ”€â”€ database/              # Modelos y configuraciÃ³n DB
â”œâ”€â”€ auth/                  # AutenticaciÃ³n
â”œâ”€â”€ data-services/         # Servicios de datos
â”œâ”€â”€ testing/               # Utilidades de testing
â”œâ”€â”€ ai/                    # Integraciones IA
â”œâ”€â”€ analytics/             # AnÃ¡lisis y mÃ©tricas
â”œâ”€â”€ cms/                   # GestiÃ³n de contenido
â”œâ”€â”€ internationalization/  # i18n
â”œâ”€â”€ notifications/         # Sistema de notificaciones
â”œâ”€â”€ payments/              # IntegraciÃ³n de pagos
â”œâ”€â”€ security/              # Configuraciones de seguridad
â”œâ”€â”€ seo/                   # SEO optimization
â”œâ”€â”€ storage/               # GestiÃ³n de archivos
â”œâ”€â”€ webhooks/              # GestiÃ³n de webhooks
â”œâ”€â”€ feature-flags/         # Control de caracterÃ­sticas
â”œâ”€â”€ observability/         # Monitoreo y logging
â”œâ”€â”€ rate-limit/            # Control de lÃ­mites
â””â”€â”€ collaboration/         # Herramientas de colaboraciÃ³n
```

## ğŸ“ Convenciones de CÃ³digo

### 1. Nomenclatura
- **Componentes**: PascalCase (`MenuCard`, `DishModal`)
- **Archivos de componentes**: PascalCase (`MenuCard.tsx`)
- **Hooks**: camelCase con prefijo `use` (`useMenuData`)
- **Utilidades**: camelCase (`formatPrice`, `validateEmail`)
- **Constantes**: UPPER_SNAKE_CASE (`API_ENDPOINTS`, `DEFAULT_LOCALE`)
- **Tipos/Interfaces**: PascalCase (`User`, `MenuConfig`)

### 2. Estructura de Archivos
```
ComponentName/
â”œâ”€â”€ index.ts              # Export barrel
â”œâ”€â”€ ComponentName.tsx     # Componente principal
â”œâ”€â”€ ComponentName.test.tsx # Tests
â”œâ”€â”€ ComponentName.stories.tsx # Storybook
â”œâ”€â”€ hooks/                # Hooks especÃ­ficos
â”œâ”€â”€ types.ts              # Tipos especÃ­ficos
â””â”€â”€ utils.ts              # Utilidades especÃ­ficas
```

### 3. Imports y Referencias
- Usar `@` para referenciar archivos: `@repo/design-system`
- Imports absolutos para packages: `import { Button } from '@repo/design-system'`
- Imports relativos solo para archivos locales: `import { utils } from './utils'`
- Agrupar imports: packages externos, packages internos, relativos

## âš›ï¸ Reglas de React/Next.js

### 1. Server vs Client Components
```typescript
// âœ… Server Component por defecto
export default function MenuPage() {
  return <div>Menu content</div>
}

// âœ… Client Component solo cuando necesario
'use client'
export default function InteractiveMenu() {
  const [selected, setSelected] = useState(null)
  return <div>Interactive content</div>
}
```

### 2. Evitar useEffect Innecesario
```typescript
// âŒ Malo - useEffect innecesario
function MenuList() {
  const [menus, setMenus] = useState([])
  
  useEffect(() => {
    fetchMenus().then(setMenus)
  }, [])
  
  return <div>{menus.map(...)}</div>
}

// âœ… Bueno - Server Component
async function MenuList() {
  const menus = await fetchMenus()
  return <div>{menus.map(...)}</div>
}

// âœ… Bueno - Client Component
function MenuList() {
  const { data: menus } = useSWR('/api/menus', fetcher)
  return <div>{menus?.map(...)}</div>
}
```

### 3. GestiÃ³n de Estado
- Usar `useState` para estado local simple
- `zustand` para estado complejo
- `Zustand` para estado global (si estÃ¡ en @repo/store)

### 4. Error Handling
```typescript
// âœ… Siempre incluir error boundaries
export default function MenuPage() {
  return (
    <ErrorBoundary fallback={<ErrorFallback />}>
      <MenuContent />
    </ErrorBoundary>
  )
}

// âœ… Manejar errores en async operations
async function fetchMenuData() {
  try {
    const data = await api.getMenus()
    return { data, error: null }
  } catch (error) {
    return { data: null, error }
  }
}
```

## ğŸ”§ Herramientas y ValidaciÃ³n

### 1. Linting y Formatting
- Usar Biome para linting y formatting
- ConfiguraciÃ³n en `biome.json`
- Ejecutar `pnpm lint` antes de commits

### 2. Testing
- Vitest para unit tests
- Testing Library para componentes
- Playwright para E2E (si estÃ¡ configurado)
- MÃ­nimo 80% de cobertura

### 3. Types
- TypeScript estricto
- Definir tipos en `types.ts` de cada mÃ³dulo
- Usar `as const` para objetos inmutables
- Evitar `any`, usar `unknown` si es necesario

## ğŸ“¦ GestiÃ³n de Dependencias

### 1. EvaluaciÃ³n de Packages
Antes de instalar cualquier package, evaluar:
1. **Â¿Existe una soluciÃ³n en nuestros packages?**
2. **Â¿Es mantenido activamente?**
3. **Â¿Tiene buena documentaciÃ³n?**
4. **Â¿Es compatible con Next.js 13+?**
5. **Â¿Afecta el bundle size significativamente?**

### 2. Package Management
- Usar `pnpm` exclusivamente
- Instalar en el workspace correcto (root, app, o package especÃ­fico)
- Mantener package.json ordenado
- Usar versiones exactas para packages crÃ­ticos

## ğŸŒ InternacionalizaciÃ³n

### 1. Estructura i18n
```typescript
// âœ… Usar @packages/internationalization con dictionary
import type { Dictionary } from '@packages/internationalization'

function MenuCard({ dish, dictionary }: { dish: Dish, dictionary: Dictionary }) {
  return (
    <div>
      <h3>{dictionary.web.menu.dishName || 'Dish Name'}</h3>
      <p>{dictionary.web.menu.price || 'Price'}: {dish.price}</p>
    </div>
  )
}

// âŒ Nunca hardcodear textos
function BadMenuCard({ dish }) {
  return (
    <div>
      <h3>Dish Name</h3> {/* âŒ Texto hardcodeado */}
      <p>Price: {dish.price}</p> {/* âŒ Texto hardcodeado */}
    </div>
  )
}
```

### 2. Locale Routing
- Usar estructura `[locale]` en rutas
- Configurar redirects en @apps/app/middleware.ts
- Manejar fallbacks apropiadamente

## ğŸ”’ Seguridad

### 1. AutenticaciÃ³n
- Usar @packages/auth para toda la autenticaciÃ³n
- Validar tokens en middleware
- Implementar RBAC apropiadamente

### 2. ValidaciÃ³n de Datos
```typescript
// âœ… Siempre validar datos de entrada
import { z } from 'zod'

const menuSchema = z.object({
  name: z.string().min(1),
  price: z.number().positive(),
  category: z.enum(['appetizer', 'main', 'dessert'])
})

function createMenu(data: unknown) {
  const validatedData = menuSchema.parse(data)
  // Procesar datos validados
}
```

## ğŸš€ Performance

### 1. OptimizaciÃ³n de ImÃ¡genes
```typescript
// âœ… Usar Next.js Image
import Image from 'next/image'

function DishImage({ dish }) {
  return (
    <Image
      src={dish.image}
      alt={dish.name}
      width={300}
      height={200}
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..."
    />
  )
}
```

### 2. Code Splitting
- Usar `dynamic` para lazy loading
- Implementar loading states
- Dividir rutas apropiadamente

### 3. Caching
- Usar Next.js caching strategies
- Implementar revalidation apropiada
- Usar @packages/rate-limit para APIs

## ğŸ“‹ Checklist de Desarrollo

Antes de crear un PR, verificar:

- [ ] âœ… CÃ³digo sigue principios SOLID
- [ ] âœ… No hay `useEffect` innecesario
- [ ] âœ… Componentes son modulares y reutilizables
- [ ] âœ… Se revisÃ³ si existe package para la funcionalidad
- [ ] âœ… No se mockearon datos sin necesidad
- [ ] âœ… Types estÃ¡n definidos correctamente
- [ ] âœ… Tests estÃ¡n escritos y pasan
- [ ] âœ… Linting pasa sin errores
- [ ] âœ… Performance es Ã³ptima
- [ ] âœ… Accesibilidad estÃ¡ implementada
- [ ] âœ… InternacionalizaciÃ³n estÃ¡ considerada
- [ ] âœ… Error boundaries estÃ¡n implementados
- [ ] âœ… SEO metadata estÃ¡ configurado

## ğŸ”„ Flujo de Trabajo

### 1. Antes de Empezar
1. Revisar packages existentes en @packages/
2. Buscar componentes similares en @packages/design-system
3. Verificar si la funcionalidad ya existe

### 2. Durante el Desarrollo
1. Usar Server Components por defecto
2. AÃ±adir Client Components solo cuando necesario
3. Implementar error handling
4. Escribir tests

### 3. Antes de Hacer Commit
1. Ejecutar `pnpm lint`
2. Ejecutar `pnpm test`
3. Verificar que la build pasa
4. Revisar el checklist de desarrollo

---

**Recuerda**: Siempre prioriza la **modularidad**, **reutilizaciÃ³n** y **mantenibilidad** del cÃ³digo. Cuando tengas dudas, consulta los packages existentes antes de crear nuevas soluciones.
